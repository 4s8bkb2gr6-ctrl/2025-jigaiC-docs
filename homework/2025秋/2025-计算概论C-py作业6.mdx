## 题集链接
<Card
  title="OpenJudge/计算概论C(py)/2025-计算概论C-py作业6"
  icon="code"
  href="http://jgcq.openjudge.cn/2025jgchw6"
  arrow="true"
  horizontal
>
</Card>

## 01：列表练习

### 题目描述
练习列表的相关操作。首先读入一个列表 L，再读入两个数 x, y。对列表 L 执行下列操作。  
在 L 的第2个位置增加元素 x，并打印列表  
删除 L 的第1个位置的元素，并打印列表    
删除 L 的第1-3位置的元素，并打印列表    
判断 L 是否包含元素 0，输出 "False" 或者 "True"  
向 L 的末尾增加元素 y，并打印列表   
输出 L 的长度   
输出 L 中最大的元素  

**输入**    
两行    
第一行作为列表的元素（列表长度大于等于3），每个元素都是一个整数，用空格隔开。   
第二行是两个整数，用空格隔开    

**输出**    
执行描述中的所有操作    

### 题解
**思路**  

**知识点**  
<ResponseField name="列表的基本操作" type="第6章组合数据类型">
</ResponseField>
**代码**  

<Tabs>
  <Tab title="尹思源">
    ```python 01：列表练习 lines icon="python"
    L = [int(i) for i in input().split(" ")]  # 获取列表
    x, y = map(int, input().split(" "))
    L.insert(1, x)
    print(L)
    del L[0]
    print(L)
    del L[0:3]
    print(L)
    if 0 in L:
        print("True")
    else:
        print("False")
    L.append(y)
    print(L)
    print(len(L))
    print(max(L))
    ```
  </Tab>
</Tabs>

## 02：校门外的树

### 题目描述
某校大门外长度为L的马路上有一排树，每两棵相邻的树之间的间隔都是1米。我们可以把马路看成一个数轴，马路的一端在数轴0的位置，另一端在L的位置；数轴上的每个整数点，即0，1，2，……，L，都种有一棵树。  
马路上有一些区域要用来建地铁，这些区域用它们在数轴上的起始点和终止点表示。已知任一区域的起始点和终止点的坐标都是整数，区域之间可能有重合的部分。现在要把这些区域中的树（包括区域端点处的两棵树）移走。你的任务是计算将这些树都移走后，马路上还有多少棵树。

**输入**    
输入的第一行有两个整数L（1 < = L < = 10000）和 M（1 < = M < = 100），L代表马路的长度，M代表区域的数目，L和M之间用一个空格隔开。接下来的M行每行包含两个不同的整数，用一个空格隔开，表示一个区域的起始点和终止点的坐标。  
**输出**    
输出包括一行，这一行只包含一个整数，表示马路上剩余的树的数目。  

### 题解
**思路**    
用长度为（L+1）的列表表示马路上的树，初始时列表中每个元素都为1，表示每个位置上都有一棵树。对于每个区域，将对应位置的元素设为0，表示这些位置上的树被移走。最后统计列表中值为1的元素个数，即为剩余的树的数目。

**知识点**  
<ResponseField name="列表的使用" type="第6章组合数据类型">
</ResponseField>
**代码**  

<Tabs>
  <Tab title="尹思源">
    ```python 02：校门外的树 lines icon="python"
    L, M = map(int, input().split())
    trees = [1] * (L + 1)
    for _ in range(M):
        a, b = map(int, input().split())
        trees[a : b + 1] = [0] * (b - a + 1)
    print(trees.count(1))
    ```
  </Tab>
  <Tab title="钱丽艳">
    ```python 02：校门外的树 lines icon="python"
    l, m = map(int, input().split())    # l:马路长，m:区域数
    ls = [1 for i in range(l+1)]    # ls中元素为1代表该位置有树，0表示没有
    for i in range(m):
        start, end = map(int, input().split())
        for j in range(start, end+1):
            ls[j] = 0
    print(ls.count(1))
    ```
  </Tab>
</Tabs>

## 03：成绩排序

### 题目描述    
给出班里某门课程的成绩单，请你按成绩从高到低对成绩单排序输出，如果有相同分数则名字字典序小的在前。  
**输入**    
第一行为n (0 < n < 20)，表示班里的学生数目；    
接下来的n行，每行为每个学生的名字和他的成绩, 中间用单个空格隔开。名字只包含字母且长度不超过20，成绩为一个不大于100的非负整数。  
**输出**    
把成绩单按分数从高到低的顺序进行排序并输出，每行包含名字和分数两项，之间有一个空格。    

### 题解
**思路**  


**知识点**  
<ResponseField name="字典排序" type="第6章组合数据类型">
</ResponseField>
**代码**  

<Tabs>
  <Tab title="尹思源">
    ```python 03：成绩排序 lines icon="python"
    # 利用字典实现
    n = int(input())
    students = {}
    for i in range(n):
        name, score = input().split()
        students[name] = int(score)
    students = sorted(students.items(), key=lambda x: (-x[1], x[0]))
    for student in students:
        print(student[0], student[1])
    ```
  </Tab>
  <Tab title="钱丽艳">
    ```python 03：成绩排序 lines icon="python"
    # 利用列表实现
    n = int(input())
    scores = []
    for i in range(n):
        row = input().split()
        scores.append(row)
    scores.sort(key=lambda x: (-int(x[1]), x[0]))
    for i in scores:
        print(i[0], i[1])
    ```
  </Tab>
</Tabs>

## 04：矩阵换行求边缘和

### 题目描述
输入一个整数矩阵，交换其中的两行，然后计算位于矩阵边缘的元素之和。所谓矩阵边缘的元素，就是第一行和最后一行的元素以及第一列和最后一列的元素。   
**输入**   
第一行分别为矩阵的行数m和列数n（m < 100，n < 100），两者之间以一个空格分开。   
接下来输入的m行数据中，每行包含n个整数，整数之间以一个空格分开。   
在接下来是两个整数x,y，表示需要将矩阵的第x行和第y行交换一下。   
**输出**   
输出交换行之后的矩阵的边缘元素和   

### 题解
**思路**  
注意处理边界情况。当矩阵只有一行或一列时，边缘元素会重复计算。可以通过条件判断避免重复计算。

**知识点**  
<ResponseField name="列表循环" type="第6章组合数据类型">
</ResponseField>
**代码**  

<Tabs>
  <Tab title="尹思源">
    ```python 04：矩阵换行求边缘和 Solution 1 lines icon="python"
    m, n = map(int, input().split())
    # matrix = [[int(x) for x in input().split()] for i in range(m)]  # 本行可替换下面的4行代码
    matrix = []
    for i in range(m):
        row = list(map(int, input().split()))
        matrix.append(row)
    x, y = map(int, input().split())
    matrix[x - 1], matrix[y - 1] = matrix[y - 1], matrix[x - 1]
    edge_sum = 0
    for i in range(m):
        for j in range(n):
            if i == 0 or i == m - 1 or j == 0 or j == n - 1:
                edge_sum += matrix[i][j]
    print(edge_sum)
    ```
  </Tab>
</Tabs>

## 05：图像模糊处理 

### 题目描述
给定n行m列的图像各像素点的灰度值，要求用如下方法对其进行模糊化处理：   

1. 四周最外侧的像素点灰度值不变；   

2. 中间各像素点新灰度值为该像素点及其上下左右相邻四个像素点原灰度值的平均（舍入到最接近的整数）。   
**输入**   
第一行包含两个整数n和m，表示图像包含像素点的行数和列数。1 < = n < = 100，1 < = m < = 100。   
接下来n行，每行m个整数，表示图像的每个像素点灰度。相邻两个整数之间用单个空格隔开，每个元素均在0~255之间。   
**输出**   
n行，每行m个整数，为模糊处理后的图像。相邻两个整数之间用单个空格隔开。   
### 题解
**思路**  
注意四周最外侧的像素点灰度值不变，只处理中间的像素点。计算平均值时要考虑边界条件，确保不会访问到不存在的像素点。

**知识点**  
<ResponseField name="列表循环" type="第6章组合数据类型">
</ResponseField>
**代码**  

<Tabs>
  <Tab title="尹思源">
    ```python 05：图像模糊处理 lines icon="python"
    n, m = map(int, input().split())
    img = []
    for _ in range(n):
        row = list(map(int, input().split()))
        img.append(row)
    img_avg = [row[:] for row in img]
    for i in range(1, n - 1):
        for j in range(1, m - 1):
            total = 0
            count = 0
            for di, dj in [(-1, 0), (1, 0), (0, -1), (0, 1), (0, 0)]:
                ni, nj = i + di, j + dj
                if 0 <= ni < n and 0 <= nj < m:
                    total += img[ni][nj]
                    count += 1
            img_avg[i][j] = round(total / count)
    for row in img_avg:
        print(" ".join(map(str, row)))
    ```
  </Tab>
  <Tab title="钱丽艳">
    ```python 05：图像模糊处理 lines icon="python"
    n, m = map(int, input().split())
    ls = []
    # 获得要处理的数据，存储在一个列表中（最终为二维列表）
    for i in range(n):
        s = input().split()
        ls.append(s)
    # 处理数据
    for i in range(n):
        line = []               # 一维数组，将需要处理的行的数据，处理后放入其中
        if i == 0 or i == n-1:  # 第一行及最后一行原样输出
            print(' '.join(ls[i]))
        else:
            for j in range(m):  # 非第一行及最后一行，每一行的处理
                if j == 0 or j == m-1:  # 第一列及最后一列原样输出，无需做处理
                    line.append(ls[i][j])
                else:
                    # round()对于.5，虽有奇进偶不进，但本题因为是整数除以5所以不会出现.5的情况
                    averageV = round((int(ls[i-1][j]) + int(ls[i+1][j]) +
                                 int(ls[i][j]) +
                                 int(ls[i][j-1]) + int(ls[i][j+1]))/5, 0)                       
                    averageV = str(int(averageV))
                    line.append(averageV)
         print(' '.join(line))
    ```
  </Tab>
</Tabs>

## 06：去除重复数字

### 题目描述    
输入一组随机整数，去除重复的数字，并有序打印出来。     
**输入**    
一组随机整数，以空格分隔   
**输出**    
从小到大排序的去重数组。     

### 题解
**思路**  
可以使用集合来去除重复数字，然后将集合转换为列表并排序，最后打印结果。

**知识点**  
<ResponseField name="集合" type="第6章组合数据类型">
</ResponseField>
**代码**  

<Tabs>
  <Tab title="尹思源">
    ```python 06：去除重复数字 lines icon="python"
    nums = set(map(int, input().split()))
    nums = sorted(nums)
    for num in nums:
        print(num, end=" ")
    ```
  </Tab>
</Tabs>

## 07：字典练习

### 题目描述    
练习字典的相关操作。首先读入一些作为键值对的元素存入一个字典 D；再读入一些作为键值对的元素，如 x1 y1, x2 y2；最后读入一个值 y3。对字典 D 执行下列操作。

新增输入的键值对元素，如 x1:y1, x2:y2，程序无需考虑键值重复的问题

修改键 "a" 的值为 y3

判断字符 "c" 是否是 D 的键，输出 "False" 或者 "True"

判断整数 0 是否是 D 的值，输出 "False" 或者 "True"

判断键值对 "b":1 是否在 D 中，输出 "False" 或者 "True"     
**输入**    
三行    
第一行和第二行都是由多个键值对构成；每个键值对包括字母、数字，二者之间用空格分隔；各键值对用逗号隔开    
第三行是一个整数    
**输出**    
执行描述中的所有操作。      

### 题解
**思路**  

**知识点**  
<ResponseField name="字典的基本操作" type="第6章组合数据类型">
</ResponseField>
**代码**  

<Tabs>
  <Tab title="尹思源">
    ```python 07：字典练习 lines icon="python"
    pairs = input().split(",")
    D = {p.split()[0]: int(p.split()[1]) for p in pairs}  # D 为字典
    pairs = input().split(",")  # pairs 是一个列表
    for pair in pairs:
        key, value = pair.split()
        D[key] = int(value)
    y3 = int(input())  # y3
    D["a"] = y3
    if "c" in D:
        print(True)
    else:
        print(False)
    if 0 in D.values():
        print(True)
    else:
        print(False)
    if ("b", 1) in D.items():
        print(True)
    else:
        print(False)
    ```
  </Tab>
  <Tab title="钱丽艳">
    ```python 07：字典练习 lines icon="python"
    pairs1 = input().split(",")
    D = {p.split()[0]: int(p.split()[1]) for p in pairs1}  # D为字典
    pairs2 = input().split(",")
    P = {i.split()[0]: int(i.split()[1]) for i in pairs2}   # P为字典
    v = int(input())
    
    D.update(P)
    D["a"] = v
    print("c" in D.keys())
    print(0 in D.values())
    print(("b", 1) in D.items())
    ```
  </Tab>
</Tabs>

## 08：单词出现频率统计

### 题目描述    
统计单词出现次数并排序输出      
**输入**    
最多60,000个单词，每个一行。单词由小写字母构成，不超过30个字符。    
**输出**    
按单词出现次数从高到低输出所有单词。次数相同的，按照词典序从小到大排。      

### 题解
**思路**  
单词长度是不确定的，要使用异常处理来结束输入。使用字典统计单词出现的频率，然后对字典项进行排序，排序时先按出现次数降序，再按单词字典序升序。    

**知识点**  
<ResponseField name="字典的用法" type="第6章组合数据类型">
</ResponseField>
**代码**  

<Tabs>
  <Tab title="尹思源">
    ```python 08：单词出现频率统计  lines icon="python"
    words = {}
    while True:
        try:
            word = input()
            words[word] = words.get(word, 0) + 1
        except EOFError:
            break
    words = sorted(words.items(), key=lambda x: (-x[1], x[0]))
    for word, count in words:
        print(f"{count} {word}")
    ```
  </Tab>
</Tabs>

## 09：网站网页访问统计

### 题目描述    
某网站上中有某一天内用户访问的网页的记录，程序要统计出访问时长最多的网页。

输入的数据是这样的格式：网页 起始时间 结束时间，数据之间用空格分开。

index.html 10:25:00  10:25:06

study.html 10:25:45  10:26:01

index.html 10:26:00  10:29:03

teachers.html 10:59:01  11:01:03

每个网页的访问时间等于结束时间减起始时间（时间可化为秒数，方便计算）。这里不考虑跨24:00的情况（也就是说，给定的数据中，结束时间总是大于等于起始时间）。将时分秒化成秒数的功能，要求写一个函数。

注意有的网页（如示例中的index.html）是多次访问，时间要进行相加。       
**输入**    
第一行是一个正整数，表示后面有多少条记录。  
后面的是多行记录，每行记录包括：网页 开始时间 结束时间。三项数据用空格分开。      
**输出**    
访问时长最长的网页       

### 题解
**思路**  
使用一个函数来将时分秒转换为秒数，然后使用字典来累计每个网页的访问时间，最后找出访问时间最长的网页。    
**知识点**  
<ResponseField name="字典的用法" type="第6章组合数据类型">
</ResponseField>
**代码**  

<Tabs>
  <Tab title="尹思源">
    ```python 09：网站网页访问统计  lines icon="python"
    def diff(start, end):
        sh, sm, ss = map(int, start.split(":"))
        eh, em, es = map(int, end.split(":"))
        start_total = sh * 3600 + sm * 60 + ss
        end_total = eh * 3600 + em * 60 + es
        return end_total - start_total


    webs = {}
    num = int(input())
    for i in range(num):
        web, start, end = input().split()
        time = diff(start, end)
        webs[web] = webs.get(web, 0) + time
    webs = sorted(webs.items(), key=lambda x: (-x[1], x[0]))
    print(webs[0][0])
    ```
  </Tab>
  <Tab title="钱丽艳">
    ```python 09：网站网页访问统计  lines icon="python"
    def timeToSecond(tList):
    return tList[0] * 3600 + tList[1] * 60 + tList[2]


    n = int(input())
    d = {}  # {url1: visitTimes, ......}
    for i in range(n):
        ls = input().split()
        url = ls[0]
        startT = timeToSecond(list(map(int, ls[1].split(":"))))
        endT = timeToSecond(list(map(int, ls[2].split(":"))))
        if ls[0] not in d:  # 添加键值对
            d[url] = 0
        d[url] += endT - startT
    lsT = sorted(d.items(), key=lambda item: item[1], reverse=True)
    print(lsT[0][0])
    ```
  </Tab>
</Tabs>

## 10：单词打分（提高版）

### 题目描述    
大家一起在学习单词时，会对学习的单词评分，评分越高，单词越难。现在每个人都对10个单词评分，不同的人可能对同一个单词评分，求最简单的单词。最简单的单词必须被评过分；如果单词被多人评分，它的综合评分是这些评分的平均数；不会出现多个最简单单词。       
**输入**    
人数n，n∈[3,10] 
后续共n*10行，分别表示每一个人对10个单词的打分。    
每一行第一个数字代表人的id，第二个为打分单词，第三个为对应分数（分数为1-10之间的整数）。        
**输出**    
最简单的单词    
给最简单单词打过分的id，以空格分隔      

### 题解
**思路**  

**知识点**  
<ResponseField name="字典的用法" type="第6章组合数据类型">
</ResponseField>
**代码**  

<Tabs>
  <Tab title="尹思源">
    ```python 10：单词打分（提高版）  lines icon="python"
    n = int(input())
    words = {}
    for i in range(n * 10):
        ID, word, score = input().split()
        score = int(score)
        if word not in words:
            words[word] = ([ID], [score])
        else:
            words[word][0].append(ID)
            words[word][1].append(score)
    min_score = 1e9
    min_word = ""
    for word in words:
        avg_score = sum(words[word][1]) / len(words[word][1])
        if avg_score < min_score:
            min_score = avg_score
            min_word = word
    print(min_word)
    for word in words[min_word][0]:
        print(word, end=" ")
    ```
  </Tab>
</Tabs>

## 11：小鹿的工作和休息时间

### 题目描述    
作为侦探，小鹿一刻不停地利用传送点在提瓦特大陆的各处奔波。每天他都会收到许多委托信件，他需要与委托人们见面以倾听事件的情况。每天他都会收到许多委托信件，他需要与委托人们见面以倾听事件的情况。委托人们的空闲时间各不相同并且有长有短，小鹿会排满自己的工作时间接受他们的委托并与其约见，在尽可能多见委托人的基础上，会和每个委托人尽可能充分交谈。  

由于小鹿不喜欢工作与休息状态的切换，因此他希望连续工作尽可能长的一整段时间，然后就开始休息。如果有多段可选的工作时间长度相同，就选最早的一段。他想计算在这个前提下，他的工作时间段和休息时间段分别如何分布。        
**输入**    
第一行为小鹿今天的起床时间和入睡时间l,r。   
第二行为委托数目n。 
第三行起共n行，每行为某个委托人的空闲时间li,ri。     
**输出**    
第一行为小鹿今天的工作时间段，即开始工作的时间和结束工作的时间，用空格隔开。    
第二行（及可能有的第三行）为小鹿今天的休息时间段，按时间顺序输出。       

### 题解
**思路**  
整体思路与“校门口的树”相似，注意处理工作时间段的起始和结束位置。    
例如（1，2）和（3，4）是不相连的，如果将它们合并为（1，4），则会影响后续最长工作时间段的计算。  

**知识点**  
<ResponseField name="" type="第6章组合数据类型">
</ResponseField>
**代码**  

<Tabs>
  <Tab title="尹思源">
    ```python 11  lines icon="python"
    a = input().split()
    x, y = int(a[0]), int(a[1])

    length = y - x  # MOD

    keng = [0] * max(0, length)

    n = int(input())
    for i in range(n):
        si = input().split()
        li, ri = int(si[0]), int(si[1])
        if li > ri:
            li, ri = ri, li

        L = max(li, x)
        R = min(ri, y)

        if L < R:
            length = R - L  # MOD
            keng[L - x : R - x] = [1] * length

    lst = []
    d = {}
    nums = 0
    start = 0
    for i in range(length):
        if keng[i] == 1:
            if nums == 0:
                nums = 1
                start = i
            else:
                nums += 1
        else:
            if nums > 0:
                if nums not in lst:
                    lst.append(nums)
                    d[nums] = [start, i]
                nums = 0

    # 收尾：若以 1 结束
    if nums > 0:
        if nums not in lst:
            lst.append(nums)
            d[nums] = [start, length]

    if lst:
        maximum = max(lst)
        work_l_idx, work_r_idx = d[maximum]
        work_l = work_l_idx + x
        work_r = work_r_idx + x

        print(work_l, work_r)

        if work_l > x:
            print(x, work_l)
        if work_r < y:
            print(work_r, y)
    else:
        print(x, x)
        if x < y:
            print(x, y)

    ```
  </Tab>
  <Tab title="钱丽艳">
    ```python 11  lines icon="python"
    # 获取数据
    gTime, fTime = map(int, input().split())
    n = int(input())
    ls = []  # 构造列表，存储委托人的时间
    for i in range(n):
        startTime, endTime = map(int, input().split())
        ls.append((startTime, endTime))
    
    # 处理数据
    ## 对委托人的时间进行排序
    ls.sort()
    ## 构造列表，存储连续的工作时段
    result=[]   # result的元素为列表[workStartTime, workEndTime]
    for t in ls:
        if len(result)==0:  # 第一次循环，将ls中的第一个元素直接添加到result
            result.append([t[0], t[1]])
        else:
            # 判断下一个客户的时间是否与上一个客户有重叠
            # 有重叠（连续）
            if t[0] <= result[-1][1]:   # 如果下一个客户的开始时间小于等于上一个客户的结束时间，则有重叠
                '''
                如果有重叠并且下一个客户的结束时间大于上一个客户的结束时间，则更新连续工作时间段的结束时间
                '''
                if t[1]>result[-1][1]:   
                    result[-1][1]=t[1]
            # 无重叠（不连续）
            else:
                result.append([t[0], t[1]])  # 新增另一段工作时间
    ## 计算最长工作时间，相同则看工作的开始时间
    result.sort(key=lambda x:(x[1]-x[0], x[0]), reverse=True)
    
    # 输出结果
    workStart, workEnd, restLs = result[0][0], result[0][1], []    
    ## 输出工作时间段
    print(workStart, workEnd)
    ## 输出休息时间段（最多两段休息时段）
    if workStart > gTime:  # 如果工作开始时间大于起床时间，增加一个休息时段
        print(gTime, workStart)
    if workEnd < fTime:    # 如果工作结束时间小于入睡时间，增加一个休息时段
        print(workEnd, fTime)
    ```
  </Tab>
</Tabs>

---
<div className="text-center text-xs text-gray-400 mt-10">
  贡献者：尹思源
  上次修改：2025/11/20
</div>
---
